#ifndef RPC_CLUSTER_H__
#define RPC_CLUSTER_H__

#include "rpc/server.h"
#include "rpc/node_address.h"
#include "rpc/protocol.h"
#include <mp/pthread.h>
#include <algorithm>
#include <iterator>

namespace rpc {


class cluster;
class basic_node;
typedef mp::shared_ptr<basic_node> shared_node;
typedef mp::weak_ptr<basic_node>   weak_node;


struct lost_node_error : public std::runtime_error {
	lost_node_error() : std::runtime_error("node is lost") { }
};

class basic_node {
public:
	basic_node(const address& addr, cluster* srv);
	virtual ~basic_node();

	typedef std::auto_ptr<msgpack::zone> auto_zone;
	typedef rpc::msgobj      msgobj;
	typedef rpc::method_id   method_id;
	typedef rpc::msgid_t     msgid_t;
	typedef rpc::responder   responder;
	typedef rpc::shared_zone shared_zone;
	typedef rpc::shared_node shared_node;
	typedef rpc::weak_node   weak_node;

	virtual void dispatch_request(weak_node self,
			method_id method, msgobj param,
			responder& response, auto_zone& z) = 0;

public:
	// call remote procedure.
	// if the session is not exist, connect to the session.
	// if is_lost() == true, lost_node_error will be thrown.
	template <typename Parameter>
	void call(method_id method, Parameter& params,
			shared_zone& life, callback_t callback,
			unsigned short timeout_steps);

	// return true if destructor of this instance is runninng.
	bool is_lost() const;

private:
	typedef std::vector<weak_session> sessions_t;
	sessions_t m_sessions;

	address m_addr;
	cluster* m_server;

	unsigned short m_timeout_steps;

public:
	cluster* get_server();

public:
	inline bool step_timeout(unsigned short node_timeout_steps);
	void lost_node();

private:
	basic_node();
	basic_node(const basic_node&);
};


template <typename IMPL, role_type ID>
class node : public basic_node {
public:
	node(const address& addr, cluster* srv);
	virtual ~node();

	static const role_type role_id = ID;

	virtual void dispatch_request(shared_node& self,
			method_id method, msgobj param,
			responder& response, auto_zone& z);

	// void dispatch(shared_node& self,
	//		method_id method, msgobj param,
	// 		responder& response, shared_zone& life);

private:
	node();
	node(const node&);
};


class cluster : protected server {
public:
	cluster(role_type self_id,
			const address& self_addr,
			unsigned short node_timeout_steps,
			unsigned short connect_retry_limit,
			unsigned short connect_timeout_steps,
			unsigned int reconnect_timeout_msec);
	~cluster();

	typedef rpc::responder   responder;
	typedef rpc::shared_zone shared_zone;
	typedef rpc::shared_node shared_node;
	typedef rpc::weak_node   weak_node;

	// register implementation of role<IMPL, ID> for ID
	template <typename Node>
	void register_role();

	virtual void new_node(const address& addr, role_type id, shared_node& n) { };
	virtual void lost_node(const address& addr, role_type id) { };

public:
	// step timeout count.
	void step_timeout();

	// add accepted connection
	// specify peer's source address for addr argument.
	void add(int fd, const address& addr);

	// get/create RPC stub instance for the address.
	template <typename Node>
	shared_node get_node(const address& addr);

	// apply function to all nodes for the Node class.
	// F is required to implement
	// void operator() (std::pair<address, shared_node>&);
	template <typename Node, typename F>
	void for_each_node(F f);

	// get 'current' node list for the Node class.
	// the list may change after a moment.
	template <typename Node>
	void nodes(std::vector< std::pair<address, shared_node> >& result);


	// call server::add<Transport>
	template <typename Transport>
	void unmanaged_add(int fd, const address& addr);

	// call server::get_session<Transport>
	template <typename Transport>
	shared_session unmanaged_get_session(const address& addr);

	// call server::connect_session<Transport>
	template <typename Transport>
	bool unmanaged_connect_session(const address& addr);

	// call server::call<Transport, Parameter>
	template <typename Transport, typename Parameter>
	void unmanaged_call(const address& addr,
			method_id method, Parameter& params,
			shared_zone& life, callback_t callback,
			unsigned short timeout_steps);

public:
	shared_session get_session(const address& addr);

private:
	role_type m_self_id;
	address m_self_addr;

	class init_sender;
	class connection;

	shared_node bind_node(role_type id, const address& addr);
	friend class connection;

	void transport_lost(const address& addr, shared_session& s);

private:
	template <typename IMPL>
	struct role_info_tag { };

	class role_info {
	public:
		role_info();

		template <typename Node>
		role_info(role_info_tag<Node>);

		bool is_valid() const;

		shared_node get_node(const address& addr, cluster* self);

		inline void step_timeout(role_type id, cluster* self,
				unsigned short node_timeout_steps);

	private:
		typedef std::map<address, shared_node> nodes_t;
		nodes_t m_nodes;
		friend class cluster;

		shared_node (*m_node_creator)(const address& addr, cluster* self);

		template <typename Node>
		static shared_node node_creator(const address& addr, cluster* self);
	};

	typedef std::vector<role_info> role_table_t;
	role_table_t m_role_table;

	mp::pthread_mutex m_role_table_mutex;

	role_info* get_role_info(role_type id);

	unsigned short m_node_timeout_steps;
	unsigned short m_connect_retry_limit;
};


inline cluster::cluster(
		role_type self_id,
		const address& self_addr,
		unsigned short node_timeout_steps,
		unsigned short connect_retry_limit,
		unsigned short connect_timeout_steps,
		unsigned int reconnect_timeout_msec) :
	server(connect_timeout_steps, reconnect_timeout_msec),
	m_self_id(self_id),
	m_self_addr(self_addr),
	m_node_timeout_steps(node_timeout_steps),
	m_connect_retry_limit(connect_retry_limit)
{
	if(m_node_timeout_steps <= 0) {
		// node_timeout_steps == 0 causes problem
		// in basic_node::step_timeout
		m_node_timeout_steps = 1;
	}
}

inline cluster::~cluster() { }


inline basic_node::basic_node(const address& addr, cluster* srv) :
	m_addr(addr), m_server(srv),
	m_timeout_steps(25) { }

template <typename IMPL, role_type ID>
node<IMPL, ID>::node(const address& addr, cluster* srv) :
	basic_node(addr, srv) { }

template <typename IMPL, role_type ID>
node<IMPL, ID>::~node() { }


template <typename IMPL, role_type ID>
void node<IMPL, ID>::dispatch_request(shared_node& self,
		method_id method, msgobj param,
		responder& response, auto_zone& z)
{
	shared_zone life(new mp::zone());
	life->push_finalizer(&mp::object_delete<msgpack::zone>, z.get());
	z.release();
	static_cast<IMPL*>(this)->dispatch(self, method, param, response, life);
}


template <typename Parameter>
void basic_node::call(method_id method, Parameter& params,
		shared_zone& life, callback_t callback,
		unsigned short timeout_steps)
{
	if(is_lost()) {
		throw lost_node_error();
	}

	for(sessions_t::iterator it(m_sessions.begin());
			it != m_sessions.end(); ) {
		shared_session s(it->lock());
		if(s) {
			s->call(method, params, life, callback, timeout_steps);
			return;
		} else {
			it = m_sessions.erase(it);
		}
	}
	shared_session s( m_server->get_session(m_addr) );
	m_sessions.push_back(weak_session(s));
	s->call(method, params, life, callback, timeout_steps);
}

inline bool basic_node::is_lost() const
{
	return m_server == NULL;
}

template <typename Node>
void cluster::register_role()
{
	mp::pthread_scoped_lock lk(m_role_table_mutex);

	if(m_role_table.size() < Node::role_id+1) {
		m_role_table.resize(Node::role_id+1);
	}

	m_role_table[Node::role_id] = role_info(role_info_tag<Node>());
}

template <typename Node>
shared_node cluster::get_node(const address& addr)
{
	mp::pthread_scoped_lock lk(m_role_table_mutex);

	role_info* info = get_role_info(Node::role_id);
	if(!info) { throw std::logic_error("unregistered role"); }

	return info->get_node(addr, this);
}

template <typename Node, typename F>
inline void cluster::for_each_node(F f)
{
	mp::pthread_scoped_lock lk(m_role_table_mutex);

	role_info* info = get_role_info(Node::role_id);
	if(!info) { throw std::logic_error("unregistered role"); }

	std::for_each(info->m_nodes.begin(), info->m_nodes.end(), f);
}

template <typename Node>
void cluster::nodes(std::vector< std::pair<address, shared_node> >& result)
{
	mp::pthread_scoped_lock lk(m_role_table_mutex);

	role_info* info = get_role_info(Node::role_id);
	if(!info) { throw std::logic_error("unregistered role"); }

	result.reserve(info->m_nodes.size());
	std::copy(info->m_nodes.begin(), info->m_nodes.end(),
			std::back_inserter(result));
}

inline cluster::role_info* cluster::get_role_info(role_type id)
{
	if(m_role_table.size() < id) { return NULL; }
	role_info& info(m_role_table[id]);
	if(!info.is_valid()) { return NULL; }
	return &info;
}


template <typename Transport>
void cluster::unmanaged_add(int fd, const address& addr)
{
	server::add<Transport>(fd, addr);
}

template <typename Transport>
shared_session cluster::unmanaged_get_session(const address& addr)
{
	return server::get_session<Transport>(addr);
}

template <typename Transport>
bool cluster::unmanaged_connect_session(const address& addr)
{
	return server::connect_session<Transport>(addr);
}

template <typename Transport, typename Parameter>
void cluster::unmanaged_call(const address& addr,
		method_id method, Parameter& params,
		shared_zone& life, callback_t callback,
		unsigned short timeout_steps)
{
	server::call(addr, method, params, life, callback, timeout_steps);
}

inline cluster::role_info::role_info() :
	m_node_creator(NULL) { }

template <typename Node>
cluster::role_info::role_info(role_info_tag<Node>) :
	m_node_creator( &role_info::node_creator<Node> ) { }

inline bool cluster::role_info::is_valid() const
	{ return m_node_creator != NULL; }

inline shared_node cluster::role_info::get_node(const address& addr, cluster* self)
{
	nodes_t::iterator it = m_nodes.find(addr);
	if(it != m_nodes.end()) {
		return it->second;
	} else {
		return m_nodes.insert( nodes_t::value_type(
			addr, (*m_node_creator)(addr, self)
			) ).first->second;
		//return m_nodes[addr] = (*m_node_creator)(addr, self);
	}
}

template <typename Node>
shared_node cluster::role_info::node_creator(const address& addr, cluster* self)
{
	LOG_INFO("new node ",addr);
	shared_node n(new Node(addr, self));
	self->new_node(addr, Node::role_id, n);
	return n;
}


}  // namespace rpc

#endif /* rpc/cluster.h */

