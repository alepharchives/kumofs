<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta content="application/xhtml+xml; charset=UTF-8" http-equiv="content-type" />
    <meta content="text/css" http-equiv="content-style-type" />
    <meta content="text/javascript" http-equiv="content-script-type" />
    <title>Kumofs memo -- Kumo Fast Storage rev.1012</title>
    <meta content="FURUHASHI Sadayuki" name="author" />
  </head>
  <body>
    <h2>概要</h2>
    <p>kumofsはkey-value型のデータを保存する分散ストレージ。key=&gt;valueを保存する<strong>set</strong>、keyを取得する<strong>get</strong>、keyを削除する<strong>delete</strong>の3つの操作をサポートする。</p>
    <p>データを保持する<strong>Server</strong>、Server群を管理する<strong>Manager</strong>、アプリケーションからのリクエストをServerに中継する<strong>Gateway</strong>の3種類のノードでシステムを構成する。</p>
    <p>データは複数のServerに分散して保存されるため、Serverを追加するほど性能が向上する。</p>
    <p>データは3台のServerにコピーされて保存される。2台までならServerがダウンしても動作し続ける。</p>
    <p>Server群はManagerによって死活監視されている。Serverがダウンしたら、そのServerは直ちにシステムから切り離される。ただし1台か2台のManagerが起動していないとServerの切り離しが行われないので、Managerが1台も起動していない状態でServerがダウンするとシステムが停止してしまう。</p>
    <p>Serverを追加したり切り離したりした後、その状態をシステムに反映するには、レプリケーションされたデータの再配置を行う必要がある。これは自動では行われず、<strong>kumoctlコマンド</strong>を使って手動で行う。</p>
    <br />
    <h3>Consistent Hashing</h3>
    <p>Consistent Hashingを使ってデータを分散して保存する<sup class="footnote">
        <a title="ハッシュ関数はSHA-1で、下位64ビットのみ使う。仮想ノードは128台" id="footnote4-1-anchor" href="#footnote4-1">*1</a>
      </sup>。</p>
    <p>Serverがダウンしたときは、そのServerの仮想ノードに<strong>faultフラグ</strong>がセットされる。set/get/deleteはfaultフラグがセットされたServerをスキップして行われる。つまり、通常動作時はレプリケーションは3つ作成されるが、1台がfault状態ならコピーは2つ、2台がfault状態ならコピーは1つしか作成されないkeyが存在することになる。fault状態のServerが3台以上になると、get/set/deleteが失敗し続けるkeyが存在することになる。</p>
    <p>Serverがダウンしてもfaultフラグがセットされるだけで、レプリケーションの再配置は行われない。faultフラグがセットされたServerが存在する状態で、kumoctlコマンドを使って<strong>detach</strong>コマンドをManagerに送信すると、faultフラグがセットされたServerがハッシュ空間から取り除かれる。同時にレプリケーションの再配置が行われ、すべてのkeyに対してレプリケーションが3つ作成されるようにデータがコピーされる。</p>
    <p>Serverが追加されてもすぐにはハッシュ空間には追加されず、レプリケーションの再配置は行われない。新たなServerが起動している状態で、kumoctlコマンドを使って<strong>attach</strong>コマンドをManagerに送信すると、新しいServerがハッシュ空間に追加される。同時にレプリケーションの再配置が行われ、すべてのkeyに対してレプリケーションが3つだけ存在するようにデータが移動される。</p>
    <p># TODO: auto-replace</p>
    <h3>set/get/deleteの保証範囲</h3>
    <h4>set(key, value)</h4>
    <p>key=&gt;valueを保存する。保存できれば成功を返す。保存できなければエラーを返す。</p>
    <p>既にkeyが保存されていたとき、setが成功した場合はkeyの値は確実に上書きされている。</p>
    <p>setが失敗したとき、keyの値は不定になっている。これは失敗したときにロールバックを行わないため。ロールバックを一貫性を損なうことなく行うための高級なアルゴリズムは実装されていない/使うと性能が低下してしまう。</p>
    <p>Serverはレプリケーション先の2台〜0台のすべてのServerにデータが受信されたことを確認してからGatewayにレスポンスを返す。どれか1台でもコピー処理が失敗したらエラーを返す。つまり、アプリケーションに成功が返されたときはfault状態でないすべてのServerにレプリケーションがコピーされており、それ以降に古いデータが読み出されることはない。ただしディスクに書き込まれているとは限らない。</p>
    <h4>get(key)</h4>
    <p>keyをsetするリクエストが成功していた場合は、そのkeyに対応するvalueを返す。setが失敗していた場合は、nullか、setに失敗したvalueが返る。それ以外であればnullを返す。</p>
    <p>keyをsetするリクエストが成功してvalueが保存されていたとしても、レプリケーションされたすべてのServerの負荷が非常に高いために応答できない場合は、getがタイムアウトする可能性がある。</p>
    <p>keyが保存されていなかった場合はエラーにならないが、タイムアウトした場合はエラーになる。</p>
    <h4>delete(key)</h4>
    <p>keyを削除する。</p>
    <p>deleteを行ってもkeyが削除されないことがある。</p>
    <p>Serverはkeyがいつ削除されたかを記憶しているが、時間が経過すると記憶を破棄する。一斉に大量にkeyが削除されるとメモリ使用量の上限に達し、より速く記憶を破棄するようになる。このとき遅延していたレプリケーションや、遅延していた再配置が介入すると、deleteされるはずのkeyが古いkeyによって上書きされる。</p>
    <p>記憶を破棄するまでの時間とメモリの使用量はServerの引数で指定できる。</p>
    <br />
    <h3>動作環境と制限</h3>
    <h4>サーバーの時刻設定</h4>
    <p>ManagerとServerを動作させるホストの時刻設定は、TIME_ERROR_MARGIN秒（コンパイル時に決定。デフォルトでは5秒）以上ずれていると正常に動作しない。またUTCとlocaltimeはどちらかに揃える必要がある。</p>
    <p># TODO</p>
    <br />
    <div class="footnote_view">
      <p>
        <a id="footnote4-1" href="#footnote4-1-anchor">*1</a>ハッシュ関数はSHA-1で、下位64ビットのみ使う。仮想ノードは128台</p>
    </div>
    <br />
    <h2>インストールと実行</h2>
    <h3>依存関係</h3>
    <h4>動作環境</h4>
    <ul class="ul1">
      <li>linux &gt;= 2.6.18</li>
      <li>glibc &gt;= XXX</li>
    </ul>
    <h4>コンパイル時に必要なもの</h4>
    <ul class="ul1">
      <li>g++ &gt;= 4.1</li>
      <li>ragel &gt;= 6.3</li>
    </ul>
    <h4>コンパイル時と実行時に必要なもの</h4>
    <ul class="ul1">
      <li>ruby &gt;= 1.8</li>
      <li>libcrypto(openssl)</li>
      <li>zlib &gt;= XXX</li>
      <li>Tokyo Cabinet &gt;= 1.4.10</li>
      <li>MessagePack for C++ &gt;= 0.3.1</li>
      <li>MessagePack for Ruby &gt;= 0.3.1</li>
    </ul>
    <h3>コンパイル</h3>
    <p>シンプルに./configure &amp;&amp; make &amp;&amp; make installでインストールできる。</p>
    <pre class="code_sh">$ ./configure &amp;&amp; make &amp;&amp; make install
</pre>
    <p>以下の4つのコマンドがインストールされる：</p>
    <dl>
      <dt>kumo-manager</dt>
      <dd>Managerノード。Serverノードの管理をする。</dd>
      <dt>kumo-server</dt>
      <dd>Serverノード。実際にデータを保存する。</dd>
      <dt>kumo-gateway</dt>
      <dd>Gatewayノード。memcachedプロトコルのサーバーで、アプリケーションからの要求をServerノードに中継する。</dd>
      <dt>kumoctl</dt>
      <dd>Managerノードを制御するための管理コマンド</dd>
      <dt>kumostat</dt>
      <dd>Serverノードの状態を取得する</dd>
      <dt>kumotop</dt>
      <dd>Serverノードの状態を定期的に更新しながら表示する</dd>
      <dt>kumolog</dt>
      <dd>バイナリフォーマットのログをテキストフォーマットに変換する</dd>
      <dt>kumomergedb</dt>
      <dd>コールドバックアップファイルをマージする</dd>
    </dl>
    <h4>configureフラグ</h4>
    <dl>
      <dt>--with-msgpack=DIR</dt>
      <dd>MessagePackがインストールされているディレクトリを指定する</dd>
      <dt>--with-tokyocabinet=DIR</dt>
      <dd>Tokyo Cabinetがインストールされているディレクトリを指定する</dd>
      <dt>--enable-trace</dt>
      <dd>画面を埋め尽くすほど冗長なデバッグ用のメッセージを出力するようにする</dd>
      <dt>--with-tcmalloc[=DIR]</dt>
      <dd>tcmallocとリンクする</dd>
    </dl>
    <h3>実行例</h3>
    <h4>Manager 2台, Server 4台を使った冗長構成</h4>
    <p>
      <strong>s1</strong>〜<strong>s4</strong>の4台でクラスタを構成し、<strong>c1</strong>と<strong>c2</strong>で動作するアプリケーションから利用する例。</p>
    <p>s1〜s4でServerを起動し、<strong>s1</strong>と<strong>s2</strong>では同時にManagerも起動する。<strong>c1</strong>と<strong>c2</strong>ではGatewayを起動する。</p>
    <pre class="code_sh">[s1]$ kumo-manager -v -l s1 -p s2    # Manager同士は互いに指定する
[s2]$ kumo-manager -v -l s2 -p s1    # Manager同士は互いに指定する
[s1]$ kumo-server  -v -m s1 -p s2 -l s1 -s database.tch    # -mと-pでManagerを指定する
[s2]$ kumo-server  -v -m s1 -p s2 -l s2 -s database.tch    # -lは常に自ホストのアドレス
[s3]$ kumo-server  -v -m s1 -p s2 -l s3 -s database.tch    # -sはデータベース名
[s4]$ kumo-server  -v -m s1 -p s2 -l s4 -s database.tch    # -vは冗長なメッセージを出力
[c1]$ kumo-gateway -v -m s1 -p s2 -t 11211    # 11211/tcpでmemcachedテキストプロトコル
[c2]$ kumo-gateway -v -m s1 -p s2 -t 11211    # を待ち受ける
</pre>
    <h4>localhostでクラスタを構成する</h4>
    <p>localhostでManagerノード1台、Server 2台を使ってクラスタを構成する例。</p>
    <pre class="code_sh">[localhost]$ kumo-manager -v -l localhost   # Managerを1台で運用するときは-pを省略
                           # kumo-serverはポートを変えて起動する
[localhost]$ kumo-server  -v -m localhost -l localhost:19801 -L 19901 -s database1.tch
[localhost]$ kumo-server  -v -m localhost -l localhost:19802 -L 19902 -s database2.tch
[localhost]$ kumo-gateway -v -m localhost -t 11211
</pre>
    <h3>主な引数</h3>
    <h3>共通</h3>
    <dl>
      <dt>-o &lt;path.log&gt;</dt>
      <dd>ログを標準出力ではなく指定されたファイルに出力する</dd>
      <dt>-g &lt;path.mpac&gt;</dt>
      <dd>バイナリログを指定されたファイルに出力する</dd>
      <dt>-d &lt;path.pid&gt;</dt>
      <dd>デーモンになる。指定されたファイルにpidを書き出す</dd>
      <dt>-v</dt>
      <dd>WARNよりレベルの低いメッセージを出力する</dd>
      <dt>-Ci &lt;sec&gt;</dt>
      <dd>タイマークロックの間隔を指定する。単位は秒で小数を指定できる</dd>
      <dt>-Ys &lt;sec&gt;</dt>
      <dd>connect(2)のタイムアウト時間を指定する。単位は秒で小数を指定できる</dd>
      <dt>-Yn &lt;num&gt;</dt>
      <dd>connect(2)のリトライ回数を指定する</dd>
      <dt>-TR &lt;num&gt;</dt>
      <dd>送信用スレッドの数を指定する</dd>
      <dt>-TW &lt;num&gt;</dt>
      <dd>受信用スレッドの数を指定する</dd>
    </dl>
    <h4>kumo-manager</h4>
    <dl>
      <dt>-l &lt;address&gt;</dt>
      <dd>待ち受けるアドレス。<strong>他のノードから見て</strong>接続できるホスト名とポート番号を指定する</dd>
      <dt>-p &lt;address&gt;</dt>
      <dd>もし存在するなら、もう一台のkumo-managerのホスト名とポート番号を指定する</dd>
      <dt>-c &lt;port&gt;</dt>
      <dd>kumoctlからのコマンドを受け付けるポート番号を指定する</dd>
      <dt>-a</dt>
      <dd>Serverが追加・離脱されたときに、マニュアル操作を待たずにレプリケーションの再配置を自動的に行うようにする。実行中でもkumoctlコマンドを使って変更できる</dd>
      <dt>-Rs</dt>
      <dd>自動的な再配置が有効なときに、サーバーの追加・離脱を検出してからレプリケーションの再配置を開始するまでの待ち時間を指定する。単位は秒</dd>
    </dl>
    <h4>kumo-server</h4>
    <dl>
      <dt>-l &lt;address&gt;</dt>
      <dd>待ち受けるアドレス。<strong>他のノードから見て</strong>接続できるホスト名とポート番号を指定する</dd>
      <dt>-L &lt;port&gt;</dt>
      <dd>kumo-serverが待ち受けるもう一つのポートのポート番号を指定する</dd>
      <dt>-m &lt;address&gt;</dt>
      <dd>kumo-managerのホスト名とポート番号を指定する</dd>
      <dt>-p &lt;address&gt;</dt>
      <dd>もし存在するなら、もう一台のkumo-managerのホスト名とポート番号を指定する</dd>
      <dt>-s &lt;path.tch[#xmsiz=SIZE][#rcnum=SIZE]&gt;</dt>
      <dd>データを保存するデータベースファイルのパスを指定する</dd>
      <dt>-f &lt;dir&gt;</dt>
      <dd>レプリケーションの再配置に使う一時ファイルを保存するディレクトリを指定する。データベースファイルのサイズに応じて十分な空き容量が必要</dd>
      <dt>-gS &lt;seconds&gt;</dt>
      <dd>deleteしたエントリのクロックを保持しておくメモリ使用量の上限をKB単位で指定する</dd>
      <dt>-gN &lt;seconds&gt;</dt>
      <dd>deleteしたエントリのクロックを保持しておく最小時間を指定する。メモリ使用量が上限に達していると、最大時間に満たなくても最小時間を過ぎていれば削除される。</dd>
      <dt>-gX &lt;seconds&gt;</dt>
      <dd>deleteしたエントリのクロックを保持しておく最大時間を指定する</dd>
    </dl>
    <h4>kumo-gateway</h4>
    <dl>
      <dt>-m &lt;address&gt;</dt>
      <dd>kumo-managerのホスト名とポート番号を指定する</dd>
      <dt>-p &lt;address&gt;</dt>
      <dd>もし存在するなら、もう一台のkumo-managerのホスト名とポート番号を指定する</dd>
      <dt>-t &lt;port&gt;</dt>
      <dd>memcachedテキストプロトコルを待ち受けるポート番号を指定する</dd>
      <dt>-b &lt;port&gt;</dt>
      <dd>memcachedバイナリプロトコルを待ち受けるポート番号を指定する（EXPERIMENTAL）</dd>
      <dt>-G &lt;number&gt;</dt>
      <dd>getの最大リトライ回数を指定する</dd>
      <dt>-S &lt;number&gt;</dt>
      <dd>setの最大リトライ回数を指定する</dd>
      <dt>-D &lt;number&gt;</dt>
      <dd>deleteの最大リトライ回数を指定する</dd>
      <dt>-As</dt>
      <dd>set操作でレプリケーションするとき、レプリケーション完了の応答を待たずに成功を返すようにする</dd>
      <dt>-Ad</dt>
      <dd>delete操作でレプリケーションするとき、レプリケーション完了の応答を待たずに成功を返すようにする</dd>
    </dl>
    <div class="footnote_view">
      <p>
        <a id="footnote4-1" href="#footnote4-1-anchor">*1</a>ハッシュ関数はSHA-1で、下位64ビットのみ使う。仮想ノードは128台</p>
    </div>
    <br />
    <h2>ゲートウェイ</h2>
    <h3>memcached text protocol gateway</h3>
    <p>サポートしているプロトコルは以下の通り：</p>
    <ul class="ul1">
      <li>get (複数key対応。ただしflagsは常に0になる)</li>
      <li>set (ただしflagsとexptimeは0でないとエラーになる)</li>
      <li>delete (ただしexptimeは0でないとエラーになる)</li>
    </ul>
    <br />
    <h3>memcached binary protocol gateway</h3>
    <p>サポートしているプロトコルは以下の通り：</p>
    <ul class="ul1">
      <li>get    (ただしcas uniqueは0でないとエラーになる)</li>
      <li>getq   (ただしcas uniqueは0でないとエラーになる)</li>
      <li>getk   (ただしcas uniqueは0でないとエラーになる)</li>
      <li>getkq  (ただしcas uniqueは0でないとエラーになる)</li>
      <li>set    (ただしcas uniqueとflagsとexptimeは0でないとエラーになる)</li>
      <li>delete (ただしcas uniqueとexptimeは0でないとエラーになる)</li>
      <li>noop</li>
    </ul>
    <p>リクエストのパイプライン化にも対応している。</p>
    <br />
    <h2>管理コマンド</h2>
    <h3>kumoctl</h3>
    <p>kumoctlコマンドを使うとManagerの状態を取得したり、コマンドを送ったりできる。</p>
    <p>Rubyで書かれたスクリプト。実行するにはgemでmsgpackパッケージをインストールする。</p>
    <p>第1引数にManagerのホスト名とポート番号を指定し、第2引数にコマンドを指定する。</p>
    <pre class="code_sh">$ kumoctl --help
Usage: kumoctl address[:port=19799] command [options]
command:
   status                     get status
   attach                     attach all new servers and start replace
   attach-noreplace           attach all new servers
   detach                     detach all fault servers and start replace
   detach-noreplace           detach all fault servers
   replace                    start replace without attach/detach
   backup  [suffix=????????]  create backup with specified suffix
   enable-auto-replace        enable auto replace
   disable-auto-replace       disable auto replace
</pre>
    <h4>status</h4>
    <p>Managerが持っているハッシュ空間を取得して表示する。</p>
    <pre>$ kumoctl localhost status
hash space timestamp:
  Wed Dec 03 22:15:45 +0900 2008 clock 58
attached node:
  127.0.0.1:8000  (active)
  127.0.0.1:8001  (fault)
not attached node:
  127.0.0.1:8002
</pre>
    <p class="title">statusの実行例</p>
    <p>
      <strong>attached node</strong>はハッシュ空間に入っているServerの一覧を示している。<strong>(active)</strong>は正常動作中のServerで、<strong>(fault)</strong>はfaultフラグが立っているServerを示している。</p>
    <p>
      <strong>not attached node</strong>はハッシュ空間に入っていないか、入っているが(fault)状態でまだ再attachされていないServerの一覧を示している。</p>
    <p>レプリケーションの再配置を行ったとき、Managerが２台起動していれば２つのManager間で新しいハッシュ空間が同期される。ただし新しいハッシュ空間が空の時は同期されない。</p>
    <p>この理由は、障害が発生していたManagerを復旧したときに空のハッシュ空間が同期されてしまう可能性があるため。起動した直後はクロック（後述）が調整されていないために、ハッシュ空間の新旧の比較が正常に機能しない。このため空のハッシュ空間を受け取ったときは無視するようになっている。 # FIXME この動作は正しい？もっと良い回避方法は無いか？</p>
    <br />
    <h4>attach</h4>
    <p>statusで<strong>not attached node</strong>に表示されているServerをハッシュ空間に組み入れ、レプリケーションの再配置を開始する。</p>
    <h4>attach-noreplace</h4>
    <p>attachと同じだがレプリケーションの再配置を開始しない。ただし再配置をしないまま長い間放置してはいけない。</p>
    <p>再配置を行わないと、エラーが積もってGatewayから最新のハッシュ空間を要求されたとき（後述）、Gatewayが持っているハッシュ空間とServerが持っているハッシュ空間が食い違ってしまう。食い違うとsetやdeleteがいつまで経っても成功しなくなってしまう。</p>
    <h4>detach</h4>
    <p>statusで<strong>attached node</strong>に表示されていて(fault)状態のServerをハッシュ空間から取り除き、レプリケーションの再配置を開始する。</p>
    <h4>detach-noreplace</h4>
    <p>detachと同じだがレプリケーションの再配置を開始しない。再配置をしないまま長い間放置してはいけない。</p>
    <h4>replace</h4>
    <p>レプリケーションの再配置を開始する。</p>
    <h4>backup</h4>
    <p>コールドバックアップを作成する。バックアップはServerで作成され、元のデータベース名にsuffixを付けた名前のファイルにデータベースがコピーされる。手元にバックアップを持ってくるには、rsyncやscpなどを使ってServerからダウンロードする。</p>
    <p>suffixは省略するとその日の日付（YYMMDD）が使われる。</p>
    <p>作成されたバックアップファイルは、kumomergedbコマンドを使って１つのファイルに結合することができる。</p>
    <pre class="code_sh">$ kumomergedb backup.tch-20090101 \
              server1.tch-20090101 server2.tch-20090101 server3.tch-20090101
</pre>
    <p class="title">kumomergedbコマンドの実行例</p>
    <br />
    <h3>kumostat</h3>
    <p>kumostatコマンドを使うとServerの状態を取得することができる。</p>
    <p>Rubyで書かれたスクリプト。実行するにはgemでmsgpackパッケージをインストールする。</p>
    <p>第1引数にServerのホスト名とポート番号を指定し、第2引数にコマンドを指定する。</p>
    <pre>Usage: kumostat address[:port=19800] command [options]
command:
   pid                        get pid of server process
   uptime                     get uptime
   time                       get UNIX time
   version                    get version
   cmd_get                    get number of get requests
   cmd_set                    get number of set requests
   cmd_delete                 get number of delete requests
   items                      get number of stored items
</pre>
    <dl>
      <dt>pid</dt>
      <dd>kumo-serverプロセスのpidを取得する</dd>
      <dt>uptime</dt>
      <dd>kumo-serverプロセスの起動時間を取得する。単位は秒</dd>
      <dt>time</dt>
      <dd>kumo-serverプロセスが走っているホストのUNIXタイムを取得する</dd>
      <dt>version</dt>
      <dd>バージョンを取得する</dd>
      <dt>cmd_get</dt>
      <dd>GatewayからのGetリクエストを処理した回数を取得する</dd>
      <dt>cmd_set</dt>
      <dd>GatewayからのSetリクエストを処理した回数を取得する</dd>
      <dt>cmd_delete</dt>
      <dd>GatewayからのDeleteリクエストを処理した回数を取得する</dd>
      <dt>items</dt>
      <dd>データベースに入っているエントリの数を取得する</dd>
    </dl>
    <br />
    <h3>kumolog</h3>
    <p>kumologコマンドを使うとバイナリログをテキストに変換することができる。</p>
    <pre>Usage: kumolog &lt;logfile.mpac&gt;
</pre>
    <h3>kumotop</h3>
    <p>kumotopコマンドを使うとServerの状態を定期的に更新しながら表示することができる。</p>
    <p>引数に監視したいServerのアドレスを指定する。Serverのアドレスは複数指定できる。</p>
    <pre>Usage: kumotop address[:port=19800] ...
</pre>
    <h2>ログ</h2>
    <p>kumo-manager, kumo-server, kumo-gatewayは、それぞれ2種類のログを出力する:</p>
    <dl>
      <dt>テキストログ</dt>
      <dd>行区切りのテキストフォーマットのログ。通常標準出力に出力される</dd>
      <dt>バイナリログ</dt>
      <dd>MessagePackでシリアライズされたログ</dd>
    </dl>
    <p>テキストログは常に出力される。<strong>-v</strong>オプションを付けると冗長なログも出力されるようになる。テキストログはファイルに書き出すこともできるが、ログローテーションはサポートしていない。<strong>-d &lt;path.pid&gt;</strong>オプションを指定してデーモンとして起動するか、<strong>-o -</strong>オプションを指定すると、ログに色が付かなくなる。</p>
    <p>バイナリログは<strong>-g &lt;path.mpac&gt;</strong>オプションを付けたときだけ出力される。<strong>-v</strong>オプションは影響しない。バイナリログはSIGHUPシグナルを受け取るとログファイルを開き直すため、logrotateなどを使ってログローテーションができる。</p>
    <p>バイナリログは<strong>kumolog</strong>コマンドを使ってテキストに変換して読むことができる。</p>
    <pre class="code_sh">$ kumolog manager.mpac
</pre>
    <p class="title">kumologコマンドの実行例</p>
    <br />
    <h2>チューニング</h2>
    <h3>データベースのチューニング</h3>
    <p>Tokyo Cabinetのチューニングによって性能が大きく変わる。kumo-serverを起動する前にあらかじめ<strong>tchmgr</strong>コマンドでデータベースファイルを作成しておく。</p>
    <p>チューニングのパラメータはTokyo Cabinetのドキュメント参照。<a href="http://tokyocabinet.sourceforge.net/spex-ja.html">http://tokyocabinet.sourceforge.net/spex-ja.html</a>
    </p>
    <pre class="code_sh">$ tchmgr create /path/to/database.tch 1048568  # バケット数を2097136個にして作成
$ kumo-server -m localhost -s /path/to/database.tch
</pre>
    <h3>キャッシュサイズのチューニング</h3>
    <p>Tokyo Cabinetの一部のパラメータは起動時に指定する。</p>
    <p> -sオプションにしているパスの後ろに<strong>#xmsiz=XXX</strong>と指定すると、拡張マップメモリのサイズを指定できる。<strong>#rcnum=XXX</strong>と指定すると、キャッシュ機構を有効化できる。両方指定するには<strong>#xmsiz=XXX#rcnum=XXX</strong>と指定する。XXXは整数か小数で、k,m,gなどの単位を使える。</p>
    <p>拡張メモリマップとキャッシュ機構の効果についてはTokyo Cabinetのドキュメント参照。</p>
    <h3>タイムアウト時間とkeepalive間隔の調整</h3>
    <p># TODO</p>
    <br />
    <h2>死活監視と再配置</h2>
    <h3>障害の検出</h3>
    <p>ManagerとServerの接続では、あるノードにリクエストまたはレスポンスを送信しようとしたときに、そのノードとのコネクションが一本も存在せず、さらにconnect(2)が4回<sup class="footnote">
        <a title="--connect-retry-limitで指定" id="footnote4-2-anchor" href="#footnote4-2">*2</a>
      </sup>連続して失敗したら、そのノードはダウンしたと見なす。</p>
    <p>ManagerとServerは2秒間隔<sup class="footnote">
        <a title="--keep-alive-interval引数で指定" id="footnote4-3-anchor" href="#footnote4-3">*3</a>
      </sup>でkeepaliveメッセージをやりとりしているので、いつも何らかのリクエストかレスポンスを送ろうとしている状態になっている。</p>
    <p>connect(2)は次の条件で失敗する：</p>
    <ul class="ul1">
      <li>接続相手から明示的に接続を拒否された（Connection Refused）</li>
      <li>接続相手からの応答がない時間が3ステップ<sup class="footnote">
          <a title="--connect-timeout-steps引数で指定" id="footnote4-4-anchor" href="#footnote4-4">*4</a>
        </sup>続いた。1ステップは0.5秒<sup class="footnote">
          <a title="--clock-interval引数で指定" id="footnote4-5-anchor" href="#footnote4-5">*5</a>
        </sup>
      </li>
    </ul>
    <br />
    <h3>接続の検出</h3>
    <p>ManagerとServerの接続では、あるノードから接続を受け付けた後、そのノードから初期ネゴシエーションメッセージを受け取り、かつそのメッセージのフォーマットが正しければ、そのノードが新たに起動したと見なす。</p>
    <br />
    <h3>ハッシュ空間の更新</h3>
    <p>Consistent Hashingのハッシュ空間を更新できるのはManagerだけで、最新のハッシュ空間は常にManagerが持っている。</p>
    <p>通常動作時には1種類のハッシュ空間しか存在しないが、レプリケーションの再配置を行っている間は2種類のバージョンが存在する。最新のもの（Serverの追加/切り離しの更新が反映されている）は<strong>whs</strong>、1つ前のバージョン（Serverの追加/切り離しの更新が反映されていない）は<strong>rhs</strong>という名前が付いている。</p>
    <br />
    <p>Managerはkumoctlコマンドでレプリケーションの再配置を行うように指令されると、まずServerの追加/切り離しをwhsに反映する。もう1台のManagerが存在すればそのManagerに更新したwhsを送信する。</p>
    <p>次に認識しているすべてのServerにwhsを送信し、レプリケーションのコピーを行うようにコマンドを送る。Serverは自分が持っているwhsとManagerから送られてきたwhsを比較し、必要なら他のServerにデータのコピーを行う（このときデータベースを上から下まで読み込む）。Serverはコピーが終わったらwhsをrhsにコピーする。</p>
    <p>Serverはすべてのデータを確認し終えたら、Managerにコピーが終了した旨を通知する。ManagerはすべてのServerでコピーが終了した通知を受け取ったら、whsをrhsにコピーする。また、認識しているすべてのサーバーにレプリケーションの削除を行うようにコマンドを送る。Serverはwhsを参照して、自分が持っている必要がないデータがデータベースの中に入っていたら、それを削除する（このときもデータベースを上から下まで読み込む）。</p>
    <p>Managerはレプリケーションのコピーを行っている最中にServerがダウンしたことを検知したら、すべてのServerからレプリケーションのコピーが終了した通知を受け取っても、レプリケーションの削除を行わない。</p>
    <p>ServerはGatewayからget/set/deleteリクエストを受け取ったとき、そのkeyに対する割り当てノードが本当に自分であるか確認するために、getの場合はrhsを、set/deleteの場合はwhsを参照する。</p>
    <br />
    <h3>レプリケーションの再配置アルゴリズム</h3>
    <p># TODO レプリケーションの再配置アルゴリズム</p>
    <p>logic/srv_replace.cc:Server::replace_copy()</p>
    <br />
    <h2>レプリケーション</h2>
    <h3>set/deleteの伝播</h3>
    <p>Gatewayにsetリクエストを送信すると、keyにハッシュ関数を適用してハッシュ空間から検索し、一番最初にヒットしたServerに対してsetリクエストが送信される。</p>
    <p>setリクエストを受け取ったServerは、keyのハッシュをハッシュ空間から検索し、自分が確かに最初にヒットするServerかどうか確かめる。そうでなければGatewayに「ハッシュ空間が古いぞ」とエラーを返す。</p>
    <p>次にServerは、自分の次のServerと次の次のServerにデータをコピーする。このときコピー先のServerにfaultフラグが立っていたら、そのServerにはコピーしない。</p>
    <p>Gatewayはset/deleteが何回失敗しても、次のServerにフォールバックすることはない。set先のServerが別のServerに切り替わるのは、Managerから新しいハッシュ空間を届いたときのみ。</p>
    <p>以上の仕組みから、あるkeyをset/deleteするときは必ず単一のServerを経由することになる。このためほぼ同時にset/deleteされても必ず順序が付けられ、常に最新の結果がだけが残る。</p>
    <br />
    <h3>getのフォールバック</h3>
    <p>Gatewayはgetリクエストがタイムアウトしたり失敗したりすると、ハッシュ空間上の次のServerにリクエストする。それでもタイムアウトしたときは次の次のServerにリクエストする。リトライ回数の上限に達するまで、最初のServer→次のServer→次の次のServer→最初のServer→…とリトライが繰り返される。</p>
    <p>getはManagerから新しいハッシュ空間が届くのを待つことなくフォールバックする。</p>
    <br />
    <h3>タイムアウト</h3>
    <p>GatewayでもServerでもManagerでも、リクエストを送ってから10ステップ（1ステップは0.5秒<sup class="footnote">
        <a title="--clock-interval引数で指定" id="footnote4-6-anchor" href="#footnote4-6">*6</a>
      </sup>）の間にレスポンスが返ってこないと、そのリクエストはタイムアウトしてエラーになる。</p>
    <p>プログラムから見てTCPコネクションが確立しているか否かはタイムアウトには関係しない。コネクションが確立していなくても時間以内に再接続してレスポンスが返れば正常通り処理が続行され、コネクションが確立していても時間以内にレスポンスが返ってこなければタイムアウトする。</p>
    <p>GatewayはServerに送ったリクエストがエラーになった回数が5回<sup class="footnote">
        <a title="--renew-threashold引数で指定" id="footnote4-7-anchor" href="#footnote4-7">*7</a>
      </sup>以上失敗すると、Managerから最新のハッシュ空間を取得する。</p>
    <br />
    <h3>リトライ</h3>
    <p>Gatewayはsetは最大20回<sup class="footnote">
        <a title="--set-retry引数で指定" id="footnote4-8-anchor" href="#footnote4-8">*8</a>
      </sup>まで、deleteは最大20回<sup class="footnote">
        <a title="--delete-retry引数で指定" id="footnote4-9-anchor" href="#footnote4-9">*9</a>
      </sup>まで、getは最大5×(レプリケーション数==3 + 1)回<sup class="footnote">
        <a title="係数は--get-retry引数で指定" id="footnote4-10-anchor" href="#footnote4-10">*10</a>
      </sup>までリトライする。制限回数までリトライしても失敗したらアプリケーションにエラーが返される。</p>
    <div class="footnote_view">
      <p>
        <a id="footnote4-1" href="#footnote4-1-anchor">*1</a>ハッシュ関数はSHA-1で、下位64ビットのみ使う。仮想ノードは128台</p>
      <p>
        <a id="footnote4-2" href="#footnote4-2-anchor">*2</a>--connect-retry-limitで指定</p>
      <p>
        <a id="footnote4-3" href="#footnote4-3-anchor">*3</a>--keep-alive-interval引数で指定</p>
      <p>
        <a id="footnote4-4" href="#footnote4-4-anchor">*4</a>--connect-timeout-steps引数で指定</p>
      <p>
        <a id="footnote4-5" href="#footnote4-5-anchor">*5</a>--clock-interval引数で指定</p>
      <p>
        <a id="footnote4-6" href="#footnote4-6-anchor">*6</a>--clock-interval引数で指定</p>
      <p>
        <a id="footnote4-7" href="#footnote4-7-anchor">*7</a>--renew-threashold引数で指定</p>
      <p>
        <a id="footnote4-8" href="#footnote4-8-anchor">*8</a>--set-retry引数で指定</p>
      <p>
        <a id="footnote4-9" href="#footnote4-9-anchor">*9</a>--delete-retry引数で指定</p>
      <p>
        <a id="footnote4-10" href="#footnote4-10-anchor">*10</a>係数は--get-retry引数で指定</p>
    </div>
    <br />
    <h2>クロック</h2>
    <p>データベースに保存されているすべてのvalueや、ハッシュ空間には、クロック（=タイムスタンプ）が付与されている。value同士やハッシュ空間同士でどちらが新しいかを比べるために利用している。</p>
    <p>ref:<a href="http://funini.com/kei/logos/clock.shtml">Lamport Clockの解説</a>
    </p>
    <h3>クロックのフォーマット</h3>
    <p>クロックは64ビットの整数で、上位32ビットにはUNIXタイム（精度は秒）、下位32ビットにはLamport Clockが入っている。</p>
    <p>UNIXタイムが上位に入っているので、Server/Manager同士の時刻が1秒以上ずれていると、Lamport Clockに関係なく間違った比較が行われてしまう。</p>
    <h3>データベースのフォーマット</h3>
    <p>データベースにkeyを保存するとき、先頭の64ビットにkeyのハッシュを負荷して保存する。</p>
    <p>データベースにvalueを保存するとき、先頭の64ビットにクロックを付加して保存する。またその次の64ビットも予約してあるが、使っていない。</p>
    <pre>Database entry format
Big endian

key:
+--------+-----------------+
|   64   |       ...       |
+--------+-----------------+
hash
         key

value:
+--------+--+-----------------+
|   64   |16|       ...       |
+--------+--+-----------------+
clocktime
         meta
            data
</pre>
    <h3>レプリケーションでの利用</h3>
    <p>Serverから別のServerにデータをコピーするとき、後から来たsetリクエストのレプリケーションが、先に来たsetリクエストのレプリケーションを追い抜いて先行してしまうことが発生し得る。Serverはレプリケーションを受け取ったとき、既に保存されているvalueのクロックと新たに届いたvalueのクロックを比べ、新たに届いた方が新しかった場合のみデータベースを更新する。</p>
    <p>レプリケーションの再配置を行うとき、ほとんどの場合はレプリケーションされたどのServerも同じデータを持っているが、setが失敗していた場合は異なるデータを持っている可能性がある。このときどのServerが持っているデータが最新なのか比べる必要があり、クロックを利用して比較する。</p>
    <h3>Manager間の協調動作での利用</h3>
    <p>Managerが2台動作しているとき、どちらが持っているハッシュ空間が最新なのかを比べる必要がある。ハッシュ空間を更新するときに更新した時のクロックを付与しておき、比較するときにこのクロックを利用する。</p>
    <div class="footnote_view">
      <p>
        <a id="footnote4-1" href="#footnote4-1-anchor">*1</a>ハッシュ関数はSHA-1で、下位64ビットのみ使う。仮想ノードは128台</p>
      <p>
        <a id="footnote4-2" href="#footnote4-2-anchor">*2</a>--connect-retry-limitで指定</p>
      <p>
        <a id="footnote4-3" href="#footnote4-3-anchor">*3</a>--keep-alive-interval引数で指定</p>
      <p>
        <a id="footnote4-4" href="#footnote4-4-anchor">*4</a>--connect-timeout-steps引数で指定</p>
      <p>
        <a id="footnote4-5" href="#footnote4-5-anchor">*5</a>--clock-interval引数で指定</p>
      <p>
        <a id="footnote4-6" href="#footnote4-6-anchor">*6</a>--clock-interval引数で指定</p>
      <p>
        <a id="footnote4-7" href="#footnote4-7-anchor">*7</a>--renew-threashold引数で指定</p>
      <p>
        <a id="footnote4-8" href="#footnote4-8-anchor">*8</a>--set-retry引数で指定</p>
      <p>
        <a id="footnote4-9" href="#footnote4-9-anchor">*9</a>--delete-retry引数で指定</p>
      <p>
        <a id="footnote4-10" href="#footnote4-10-anchor">*10</a>係数は--get-retry引数で指定</p>
    </div>
  </body>
</html>
