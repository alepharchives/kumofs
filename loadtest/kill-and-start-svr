#!/usr/bin/env ruby

# TODO
# - 引数で svr と mgr のアドレス受けるように
# - 引数かenvでsleep時間とループしないのを指定できるように
# - 例外がでるお
# /usr/local/app/kumofs/bin/kumoctl:59:in `sysread': Interrupted system call (Errno::EINTR)
#         from /usr/local/app/kumofs/bin/kumoctl:59:in `receive_message'
#         from /usr/local/app/kumofs/bin/kumoctl:75:in `synchronize_response'
#         from /usr/local/app/kumofs/bin/kumoctl:94:in `send_request_sync'
#         from /usr/local/app/kumofs/bin/kumoctl:99:in `send_request_sync_ex'
#         from /usr/local/app/kumofs/bin/kumoctl:119:in `GetStatus'
#         from ./kill-and-start-svr:67:in `fault_count'
#         from ./kill-and-start-svr:137

[
  File.dirname(__FILE__) + "/kumostat",
  "/usr/local/app/kumofs/bin/kumostat",
  File.dirname(__FILE__) + "/kumoctl",
  "/usr/local/app/kumofs/bin/kumoctl",
].each do |f|
  if File.exists?(f)
    load f
    break
  end
end

class Node
  attr_reader :host, :port, :ip
  require "timeout"
  require "resolv"
  require "fileutils"

  def initialize(host, port)
    @host = host
    @port = port
    @con = nil
    Timeout.timeout(0.5) {
      @con = KumoServer.new(@host, @port)
    }
    @ip = Resolv.getaddress(@host)
  end

  def pid
    @con.GetStatus(KumoServer::STAT_PID)
  end

  def kill
    system("/command/svc", "-t", "/service/kumofs-svr_100")
  end

  def renew_db
    FileUtils.safe_unlink("/kumo/100/db.tch")
    FileUtils.copy_file("/kumo/100/_db.tch", "/kumo/100/db.tch", true)
  end

  def start
    system("/command/svc", "-u", "/service/kumofs-svr_100")
  end
end

class Manager
  attr_reader :host, :port

  def initialize(host, port)
    @host = host
    @port = port
  end

  def _connect
    KumoManager.new(@host, @port)
  end

  def fault_count
    fc = 0
    attached, not_attached, date, clock = _connect.GetStatus
    attached.each do |addr, port, active|
      fc = fc + 1 if ! active
    end
    return fc
  end

  def active?(svr)
    3.times do |i|
      warn "#{i}"
      begin
        attached, not_attached, date, clock = _connect.GetStatus
        attached.each do |addr, port, active|
          puts addr + " vs " + svr.ip + " " + active.to_s
          if addr == svr.ip && !active
            # warn svr.host + " is down"
            return true
          end
        end
      rescue
      end
      sleep 2
    end
    return false
  end

  def not_attach?(svr)
    3.times do |i|
      warn "#{i}"
      begin
        attached, not_attached, date, clock = _connect.GetStatus
        not_attached.each do |addr, port|
          warn addr + " vs " + svr.ip
          if addr == svr.ip
            warn svr.host + " is up"
            return true
          end
        end
      rescue
      end
      sleep 3
    end
    return false
  end

  def attach
    3.times do |i|
      begin
        _connect.AttachNewServers(true)
      rescue
      end
    end
  end

end

@svr_host = "s101" # fixme
@svr_host ||= "localhost"
@svr_port ||= KumoRPC::SERVER_DEFAULT_PORT
printf "svr=%s:%d\n", @svr_host, @svr_port
@svr = Node.new(@svr_host, @svr_port)

@mgr_host = "s102" # fixme
@mgr_port = KumoRPC::MANAGER_DEFAULT_PORT
@mgr = Manager.new(@mgr_host, @mgr_port);

do_loop = true

while do_loop
  while true
    fc = @mgr.fault_count
    printf "fault server: %d\n", fc
    if fc >= 2
      break
    end

    printf "kill svr node\n"
    @svr.kill
    if ! @mgr.active?(@svr)
      warn "svr running?"
      break
    end

    printf "renew db file\n"
    @svr.renew_db
    printf "startup svr node\n"
    @svr.start
    if ! @mgr.not_attach?(@svr)
      warn "svr down?"
      break
    end
    printf "attach\n"
    @mgr.attach
    printf "OK\n"

    break
  end

  #do_loop = false # fixme
  sleep 3
end
